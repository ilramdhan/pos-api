Tutorial Lengkap - Sesi 1: Build Kasir API dari Nol
üéØ Apa yang Akan Kita Bangun?
Hari ini kita akan bikin Kasir API - sistem kasir sederhana yang bisa:

Kelola data produk (CRUD lengkap)

Terima request lewat HTTP

Kirim response dalam format JSON

Siap di-deploy ke cloud (gratis!)

Yang keren dari Go? Binary-nya kecil banget (kurang dari 15MB) dan gak butuh runtime kayak PHP atau Node.js. Langsung jalan!

üöÄ Persiapan Awal
Yang Harus Kamu Punya
Go terinstall (cek: go version)

Text editor (VSCode recommended)

Terminal/Command Prompt

Git (untuk deploy nanti)

Buat Project Baru
# Bikin folder project
mkdir kasir-api
cd kasir-api

# Initialize Go module
go mod init kasir-api

# Bikin file main.go
touch main.go  # Mac/Linux
# atau
type nul > main.go  # Windows
Kenapa go mod init? Ini kayak npm init atau composer init - bikin file konfigurasi untuk manage dependencies. File go.mod akan dibuat otomatis.

üì¶ CODE-01: Package & Import
Buka main.go, ketik ini:

package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
)
Penjelasan Detail
package main - Ini "pintu masuk" aplikasi Go.

Setiap file Go harus punya package

package main = executable program (bisa dijalankan)

Package lain = library (dipanggil dari tempat lain)

Import - Library yang kita butuhkan:

encoding/json - Encode/decode JSON (buat API response)

fmt - Print ke console (fmt.Println)

net/http - HTTP server & handling

strconv - Convert string ke number (untuk ID dari URL)

strings - Manipulasi string (trim, split, dll)

üèóÔ∏è CODE-02: Produk Struct
Tambahkan setelah import:

// Produk represents a product in the cashier system
type Produk struct {
	ID    int    `json:"id"`
	Nama  string `json:"nama"`
	Harga int    `json:"harga"`
	Stok  int    `json:"stok"`
}
Penjelasan Detail
Struct = Blueprint data, mirip class tapi lebih simple.

Breakdown field:

ID int - ID produk (integer)

Nama string - Nama produk (text)

Harga int - Harga produk (integer, dalam rupiah)

Stok int - Jumlah stok

Tag json:"..." - Ini magic! Ketika struct di-convert ke JSON, field name akan jadi lowercase:

{
  "id": 1,        // bukan "ID"
  "nama": "...",  // bukan "Nama"
  "harga": 3500,  // bukan "Harga"
  "stok": 100     // bukan "Stok"
}
Tanpa tag, output JSON-nya bakal {"ID": 1, "Nama": "..."} - gak bagus untuk API.

Kenapa Harga int? Kita pakai integer (bukan float) karena rupiah gak punya desimal. Lebih simple & gak ada masalah floating point!

üíæ CODE-03: In-Memory Storage
// In-memory storage (sementara, nanti ganti database)
var produk = []Produk{
	{ID: 1, Nama: "Indomie Godog", Harga: 3500, Stok: 10},
	{ID: 2, Nama: "Vit 1000ml", Harga: 3000, Stok: 40},
	{ID: 3, Nama: "kecap", Harga: 12000, Stok: 20},
}
Penjelasan Detail
var produk []Produk - Variabel global berisi array of Produk.

Kenapa pakai array? Untuk sesi 1, kita fokus ke HTTP handling dulu. Sesi 2 nanti baru pakai SQLite database.

Data dummy - Produk warung Indo klasik:

Indomie Godog (favorit!)

Vit (air mineral lokal)

Kecap (buat masak)

Catatan Penting: Data ini hilang kalau server restart. Makanya namanya "in-memory". Database persisten nanti di Sesi 2.

üè• CODE-04: Health Check Endpoint
Ini endpoint pertama kita - buat ngecek server hidup atau nggak:

// localhost:8080/health
http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"status":  "OK",
		"message": "API Running",
	})
})
Penjelasan Detail
Function signature:

http.HandleFunc - Daftarkan route /health

func(w http.ResponseWriter, r *http.Request) - Anonymous function (function tanpa nama)

w - Tempat nulis response ke user

r - Data request dari user (method, headers, body, dll)

Step by step:

Set header:

w.Header().Set("Content-Type", "application/json")
Kasih tau browser: "Ini JSON ya, bukan HTML"

Bikin & kirim response:

json.NewEncoder(w).Encode(map[string]string{
    "status":  "OK",
    "message": "API Running",
})
map[string]string = object/dictionary dengan key & value string, langsung di-encode jadi JSON

Output:

{
  "status": "OK",
  "message": "API Running"
}
üìã CODE-05: Get All Produk & Create Produk
// GET localhost:8080/api/produk
// POST localhost:8080/api/produk
http.HandleFunc("/api/produk", func(w http.ResponseWriter, r *http.Request) {
	if r.Method == "GET" {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(produk)
		
	} else if r.Method == "POST" {
		// baca data dari request
		var produkBaru Produk
		err := json.NewDecoder(r.Body).Decode(&produkBaru)
		if err != nil {
			http.Error(w, "Invalid request", http.StatusBadRequest)
			return
		}

		// masukkin data ke dalam variable produk
		produkBaru.ID = len(produk) + 1
		produk = append(produk, produkBaru)

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated) // 201
		json.NewEncoder(w).Encode(produkBaru)
	}
})
Penjelasan Detail
Multi-method handler - 1 function handle GET & POST!

Checking method dengan if-else:

1. GET - Return semua produk:

if r.Method == "GET" {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(produk)
}
Array produk langsung jadi JSON array

2. POST - Create produk baru:

Step 1 - Decode JSON dari body:

var produkBaru Produk
err := json.NewDecoder(r.Body).Decode(&produkBaru)
Baca JSON dari request body

Convert ke struct Produk

&produkBaru - pointer, biar langsung isi data ke variable

Step 2 - Error handling:

if err != nil {
    http.Error(w, "Invalid request", http.StatusBadRequest)
    return
}
Kalau JSON rusak ‚Üí return 400

Step 3 - Auto-increment ID & append:

produkBaru.ID = len(produk) + 1
produk = append(produk, produkBaru)
Generate ID otomatis

Tambah ke array

Step 4 - Response:

w.WriteHeader(http.StatusCreated) // 201
json.NewEncoder(w).Encode(produkBaru)
Return produk yang baru dibuat

Test GET:

curl http://localhost:8080/api/produk
Response:

[
  {
    "id": 1,
    "nama": "Indomie Godog",
    "harga": 3500,
    "stok": 10
  },
  {
    "id": 2,
    "nama": "Vit 1000ml",
    "harga": 3000,
    "stok": 40
  },
  {
    "id": 3,
    "nama": "kecap",
    "harga": 12000,
    "stok": 20
  }
]
Test POST:

curl -X POST http://localhost:8080/api/produk \
  -H "Content-Type: application/json" \
  -d '{
    "nama": "Kopi Kapal Api",
    "harga": 2500,
    "stok": 200
  }'
Response:

{
  "id": 4,
  "nama": "Kopi Kapal Api",
  "harga": 2500,
  "stok": 200
}
üîç CODE-06: Get Produk by ID
Ini yang agak tricky - ambil ID dari URL path!

func getProdukByID(w http.ResponseWriter, r *http.Request) {
	// Parse ID dari URL path
	// URL: /api/produk/123 -> ID = 123
	idStr := strings.TrimPrefix(r.URL.Path, "/api/produk/")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		http.Error(w, "Invalid Produk ID", http.StatusBadRequest)
		return
	}

	// Cari produk dengan ID tersebut
	for _, p := range produk {
		if p.ID == id {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(p)
			return
		}
	}

	// Kalau tidak found
	http.Error(w, "Produk belum ada", http.StatusNotFound)
}
Penjelasan Detail
URL Path Parsing - Ini yang paling tricky:

URL: /api/produk/123

TrimPrefix: Hilangkan /api/produk/ ‚Üí dapat "123"

Atoi: Convert "123" string ‚Üí 123 integer

idStr := strings.TrimPrefix(r.URL.Path, "/api/produk/")
// URL: /api/produk/123 -> idStr = "123"
// URL: /api/produk/abc -> idStr = "abc"

id, err := strconv.Atoi(idStr)
// "123" -> 123 ‚úÖ
// "abc" -> error ‚ùå
Loop & Search:

for _, p := range produk {
    if p.ID == id {
        // Found! Return produk
        json.NewEncoder(w).Encode(p)
        return
    }
}
range produk - Loop semua produk

_ - Ignore index (gak butuh)

p - Current produk di loop

Return langsung kalau ketemu

Not Found:

http.Error(w, "Produk belum ada", http.StatusNotFound)
Kalau sampai sini = loop selesai, gak ketemu ‚Üí 404

Test:

# Found
curl http://localhost:8080/api/produk/1

# Not found
curl http://localhost:8080/api/produk/999
Response (Found):

{
  "id": 1,
  "nama": "Indomie Godog",
  "harga": 3500,
  "stok": 10
}
Response (Not Found):

404 Produk belum ada
‚úèÔ∏è CODE-07: Update Produk
// PUT localhost:8080/api/produk/{id}
func updateProduk(w http.ResponseWriter, r *http.Request) {
	// get id dari request
	idStr := strings.TrimPrefix(r.URL.Path, "/api/produk/")

	// ganti int
	id, err := strconv.Atoi(idStr)
	if err != nil {
		http.Error(w, "Invalid Produk ID", http.StatusBadRequest)
		return
	}

	// get data dari request
	var updateProduk Produk
	err = json.NewDecoder(r.Body).Decode(&updateProduk)
	if err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// loop produk, cari id, ganti sesuai data dari request
	for i := range produk {
		if produk[i].ID == id {
			updateProduk.ID = id
			produk[i] = updateProduk

			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(updateProduk)
			return
		}
	}
	
	http.Error(w, "Produk belum ada", http.StatusNotFound)
}
Penjelasan Detail
Combine 2 Logic:

Parse ID dari URL (kayak GET by ID)

Decode body JSON (kayak CREATE)

Step by step:

1. Parse ID dari URL:

idStr := strings.TrimPrefix(r.URL.Path, "/api/produk/")
id, err := strconv.Atoi(idStr)
2. Decode update data:

var updateProduk Produk
err = json.NewDecoder(r.Body).Decode(&updateProduk)
3. Loop & Update:

for i := range produk {
    if produk[i].ID == id {
        updateProduk.ID = id      // Keep ID!
        produk[i] = updateProduk  // Update di index i
        return
    }
}
Kenapa for i := range produk?

i = index di array (0, 1, 2, ...)

produk[i] = updateProduk - Replace produk di index tersebut

PENTING: Keep ID tetap sama! User gak bisa ganti ID

Test:

curl -X PUT http://localhost:8080/api/produk/1 \
  -H "Content-Type: application/json" \
  -d '{
    "nama": "Indomie Goreng Jumbo",
    "harga": 4000,
    "stok": 150
  }'
Response:

{
  "id": 1,  // ID tetap sama!
  "nama": "Indomie Goreng Jumbo",
  "harga": 4000,
  "stok": 150
}
üóëÔ∏è CODE-08: Delete Produk
func deleteProduk(w http.ResponseWriter, r *http.Request) {
	// get id
	idStr := strings.TrimPrefix(r.URL.Path, "/api/produk/")
	
	// ganti id int
	id, err := strconv.Atoi(idStr)
	if err != nil {
		http.Error(w, "Invalid Produk ID", http.StatusBadRequest)
		return
	}
	
	// loop produk cari ID, dapet index yang mau dihapus
	for i, p := range produk {
		if p.ID == id {
			// bikin slice baru dengan data sebelum dan sesudah index
			produk = append(produk[:i], produk[i+1:]...)
			
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{
				"message": "sukses delete",
			})
			return
		}
	}

	http.Error(w, "Produk belum ada", http.StatusNotFound)
}
Penjelasan Detail
Delete Trick - Ini yang agak magic:

produk = append(produk[:i], produk[i+1:]...)
Visualisasi:

Array sebelum delete:
Index: 0     1     2     3
Value: [A] - [B] - [C] - [D]

Mau delete index 1 (B):
produk[:1]  = [A]          // Sebelum index 1
produk[2:]  = [C, D]       // Sesudah index 1  
Append = [A] + [C, D] = [A, C, D]

Array sesudah delete:
Index: 0     1     2
Value: [A] - [C] - [D]
Breakdown:

produk[:i] - Semua element sebelum index i

produk[i+1:] - Semua element sesudah index i

append(...) - Gabungkan keduanya

... - Spread operator (buka array jadi individual elements)

Response:

json.NewEncoder(w).Encode(map[string]string{
    "message": "sukses delete",
})
Beda dari CRUD lain, DELETE gak return data. Cukup success message.

Test:

curl -X DELETE http://localhost:8080/api/produk/1
Response:

{
  "message": "sukses delete"
}
üö¶ CODE-09: Main Function & Routing
Sekarang hubungkan semua handler ke routes:

func main() {
	// GET localhost:8080/api/produk/{id}
	// PUT localhost:8080/api/produk/{id}
	// DELETE localhost:8080/api/produk/{id}
	http.HandleFunc("/api/produk/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == "GET" {
			getProdukByID(w, r)
		} else if r.Method == "PUT" {
			updateProduk(w, r)
		} else if r.Method == "DELETE" {
			deleteProduk(w, r)
		}
	})

	// GET localhost:8080/api/produk
	// POST localhost:8080/api/produk
	http.HandleFunc("/api/produk", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == "GET" {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(produk)
		} else if r.Method == "POST" {
			// baca data dari request
			var produkBaru Produk
			err := json.NewDecoder(r.Body).Decode(&produkBaru)
			if err != nil {
				http.Error(w, "Invalid request", http.StatusBadRequest)
				return
			}

			// masukkin data ke dalam variable produk
			produkBaru.ID = len(produk) + 1
			produk = append(produk, produkBaru)

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusCreated) // 201
			json.NewEncoder(w).Encode(produkBaru)
		}
	})

	// localhost:8080/health
	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"status":  "OK",
			"message": "API Running",
		})
	})

	fmt.Println("Server running di localhost:8080")

	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		fmt.Println("gagal running server")
	}
}
Penjelasan Detail
Routing dengan Anonymous Function: Semua handler pakai func(w http.ResponseWriter, r *http.Request) langsung - gak perlu bikin function terpisah untuk simple logic.

PENTING - Slash di akhir!

http.HandleFunc("/api/produk", ...)   // tanpa slash
http.HandleFunc("/api/produk/", ...)  // dengan slash
/api/produk (tanpa slash) = exact match

Match: /api/produk ‚úÖ

Tidak match: /api/produk/1 ‚ùå

/api/produk/ (dengan slash) = prefix match

Match: /api/produk/ ‚úÖ

Match: /api/produk/1 ‚úÖ

Match: /api/produk/123 ‚úÖ

Makanya kita butuh 2 route handler berbeda!

Handler Functions: Untuk GET/PUT/DELETE by ID, kita panggil function terpisah (getProdukByID, updateProduk, deleteProduk) karena logic-nya lebih kompleks.

Start Server:

http.ListenAndServe(":8080", nil)
:8080 - Port (bisa ganti ke :3000, :5000, dll)

nil - Default HTTP handler (gak pakai framework)

Run:

go run main.go
Output:

Server running di localhost:8080
Server running! Buka browser: http://localhost:8080/health

Available Endpoints
GET    /health              - Health check
GET    /api/produk          - Get all produk
POST   /api/produk          - Create produk
GET    /api/produk/{id}     - Get produk by ID
PUT    /api/produk/{id}     - Update produk
DELETE /api/produk/{id}     - Delete produk
üß™ Testing Endpoints
Pakai cURL (Command Line)
Health check:

curl http://localhost:8080/health
Get all produk:

curl http://localhost:8080/api/produk
Create produk:

curl -X POST http://localhost:8080/api/produk \
  -H "Content-Type: application/json" \
  -d '{
    "nama": "Kopi Kapal Api",
    "harga": 2500,
    "stok": 200
  }'
Get produk by ID:

curl http://localhost:8080/api/produk/1
Update produk:

curl -X PUT http://localhost:8080/api/produk/1 \
  -H "Content-Type: application/json" \
  -d '{
    "nama": "Indomie Goreng Jumbo",
    "harga": 4000,
    "stok": 150
  }'
Delete produk:

curl -X DELETE http://localhost:8080/api/produk/1
Pakai GUI Tool
Lebih enak pakai GUI? Install salah satu:

Postman - Popular, feature lengkap

Thunder Client - VSCode extension, ringan

Bruno - Open source, modern

Tutorial install ada di dokumen terpisah!

üèóÔ∏è Build Binary
Go bisa di-compile jadi single binary - gak perlu runtime!

Build Standar
go build -o kasir-api
Output: kasir-api (Mac/Linux) atau kasir-api.exe (Windows)

Size: ~10-15MB

No dependencies!

Build Production (Smaller)
go build -ldflags="-s -w" -o kasir-api
-s - Strip symbol table

-w - Strip debug info

Size: ~7-10MB (lebih kecil!)

Cross-Compilation
Build untuk Windows (dari Mac/Linux):

GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o kasir-api.exe
Build untuk Linux (dari Windows/Mac):

GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o kasir-api
Build untuk Mac (dari Windows/Linux):

GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o kasir-api
Keren kan? 1 command, bisa build untuk semua OS!

Jalankan Binary
# Mac/Linux
./kasir-api

# Windows
kasir-api.exe
Server langsung jalan - gak perlu go run lagi!

‚òÅÔ∏è Deploy ke Railway (Gratis!)
Persiapan
1. Bikin .gitignore:

kasir-api
kasir-api.exe
*.log
2. Push ke GitHub:

git init
git add .
git commit -m "Initial commit"
git branch -M main
git remote add origin https://github.com/username/kasir-api.git
git push -u origin main
Deploy di Railway
Buka railway.app

Login dengan GitHub

Click "New Project"

Pilih "Deploy from GitHub repo"

Select repo kasir-api

Railway auto-detect Go ‚Üí auto-deploy!

Dapat URL: https://kasir-api-production.up.railway.app

Test production:

curl https://kasir-api-production.up.railway.app/health
Works! üéâ

Environment Variables:

Railway auto-set PORT variable

Bisa tambah variable di dashboard

Alternative ke zeabur baca dokumen ini

üéì Apa yang Sudah Kita Pelajari?
‚úÖ Go basics (package, import, struct, function) 

‚úÖ HTTP handling (request, response, routing) 

‚úÖ JSON encoding/decoding 

‚úÖ CRUD operations (in-memory) 

‚úÖ URL path parsing 

‚úÖ Error handling 

‚úÖ Build & deployment

üí° Tips & Best Practices
1. Error Handling:

if err != nil {
    // ALWAYS handle error!
    http.Error(w, "Error message", http.StatusBadRequest)
    return
}
2. HTTP Status Codes:

200 OK - Success

201 Created - Resource created

400 Bad Request - Invalid input

404 Not Found - Resource not found

405 Method Not Allowed - Wrong HTTP method

500 Internal Server Error - Server error

3. Response Format: Konsisten pakai JSON:

w.Header().Set("Content-Type", "application/json")
json.NewEncoder(w).Encode(data)